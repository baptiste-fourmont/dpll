                      Mini-projet 1 : solveur DPLL récursif
                             fichier RENDU
                       (à remplir obligatoirement)

**Un mini-projet sans fichier RENDU rempli ne recevra pas de note.**

Date limite: 29 octobre 2021, 23h59

Identité
--------
Nombre de binôme: 2
Nom, prénom 1: FOURMONT Baptiste
Nom, prénom 2: MANYIM Olivier


Questions sur votre code
------------------------
0. Avez-vous testé que `make dpll` s'exécute sans erreurs ou warnings,
   et que ensuite `./dpll sudoku-4x4.cnf` donne la réponse attendue (voir
   fichier README) ?

make dpll s'exécute sans erreurs ni warnings, 
et lorsqu'on fait ./dpll sudoku-4x4.cnf donne 
SAT
-111 -112 113 -114 -121 -122 -123 124 -131 132 -133 -134 141 -142 -143 -144 -211 212 -213 -214 221 -222 -223 -224 -231 -232 -233 234 -241 -242 243 -244 311 -312 -313 -314 -321 322 -323 -324 -331 -332 333 -334 -341 -342 -343 344 -411 -412 -413 414 -421 -422 423 -424 431 -432 -433 -434 -441 442 -443 -444 0

---

1. Avez-vous utilisé la fonction `filter_map` (donné dans dpll.ml)
   dans votre implémentation de `simplifie` ? 
   - Si oui, expliquez en quelques phrases en français comment vous
     l'avez utilisée.
   - Si non, expliquez en quelques phrases en français comment
     fonctionne votre implémentation de `simplifie`.

Oui, nous avons utilisé la fonction filter_map dans l'implémentation de simplifie.
Elle nous permettait de simplifié beaucoup de chose avec les options:
   On pouvait directement filtrer la liste plus facilement:
      Comme filter_map attend un filtre puis une (clauses)
      On a créer une fonction filter permettant de dire :
         - Si il y a un i dans la clause ca veut dire que la clause est vrai donc on la met à None (Supprime la clause)
         - Sinon 
            A l'aide de Some on vérifie que chaque element n'est pas (-i) et on l'ajoute, si c'est un (-i) on le supprime
            et on fait ca pour tout les elements
---

2. Pour l'implémentation de `unitaire`, quelles sont les fonctions
   auxiliaires que vous avez utilisées et/ou écrites ? (Par une
   fonction auxiliaire, on entend ici soit une fonction d'une
   bibliothèque, par exemple des fonctions comme `List.length`,
   `List.rev_append`, ou une fonction `aux_unitaire` que vous avez
   écrite vous-mêmes.) Expliquez en quelques phrases en français
   comment ces fonctions auxiliaires sont utilisées dans votre
   implémentation de la fonction `unitaire`.

On a utilisé comme fonction auxiliaire List.length liste et List.hd liste (ou liste est une liste)
List.length permettait d'avoir la taille de la clause en paramètre
List.hd permet de retourner le premier element de la liste
   On a utilisé une sous fonction recursive check qui vérifie si la longueur de la clause est égale à 1 ( avec List.length liste)
   Si c'est le cas on retourne le premier element de la liste avec List.hd ( car forcement elle est de taille 1 donc le premier element   est celui souhaite ) et la fonction se termine
   Sinon on rappelle check avec la clause suivante jusqu'a trouver une clause de longueur une.
   Et si il n'y a pas de clause on lève une exception Not_found ou si on atteind la fin de la liste et qu'on ne trouve aucune clause unitaire
---

3. Pour l'implémentation de `pur`, quelles sont les fonctions
   auxiliaires que vous avez utilisées et/ou écrites ?  Expliquez en
   quelques phrases en français comment ces fonctions auxiliaires sont
   utilisées dans votre implémentation de la fonction `pur`.

Pour l'implémentation de pur on utilise deux fonctions auxiliaires qui sont: List.flatten et List.mem
List.flatten permet d'applatir la liste ( concatainer les listes ) 
List.mem permet de mettre un element à true si il appartient à la liste

Alors on a utilisé dans une fonction recursive check qui attend en paramètre une liste
   Tout d'abord on appelle List.flatten sur l'ensemble de clauses afin de créer une grande liste, ca nous permettra de parcourir uniquement une grande liste au lieu de se balader dans chaque liste.
   Puis on parcours cette grande liste et on vérifie à l'aide List.mem :
      que (si l'element actuelle n'est pas d'accumulateur ou que son dual n'est pas dans l'accumulateur ) et que le dual de cette element n'est pas dans la fin de la liste alors cette element est pur.
      Sinon on reparcourt la liste
      Et si on atteint de la fin de la liste ou que la liste est vide on lève une execption
---

4. Donnez un exemple d'une formule pour laquelle les deux fonctions
   `solveur_split` et `solveur_dpll_rec` ont un comportement
   différent, et expliquez les différences entre ces deux fonctions.

Dans les exemples fourni on a let exemple_7_2 = [[1;-1;-3];[-2;3];[-2]]
Qui n'a pas le même comportement pour le solveur split et rec
On obtient: 
   SAT
   1 -2 0 (solveur_split)
   SAT
   -2 -3 0 (solveur_dpll_rec)
On a une diffèrence entre ses deux fonctions car le solveur_dpll_rec contient des ordres de priorités que ne possède pas le solveur_split
Telle que d'abord on simplifie par un pur ou par un unitaire au lieu tandis que split simplifie directement les clauses.
C'est par l'utilisation de pur et unitaire dans solveur_dpll_rec et par cette ordre de priorité qu'on obtient une différence entre ses deux solveurs  
---

5. Avez-vous d'autres remarques sur votre rendu ? (question optionnelle)
Aucune question 
---

--fin du fichier RENDU--